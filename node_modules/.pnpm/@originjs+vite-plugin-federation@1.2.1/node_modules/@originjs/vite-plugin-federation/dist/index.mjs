import * as path from "path";
import { posix, basename, resolve, join, extname, relative, dirname, parse } from "path";
import MagicString from "magic-string";
import { readFileSync, statSync, readdirSync } from "fs";
import "crypto";
const PREFIX = `\0virtual:`;
function virtual(modules) {
  const resolvedIds = /* @__PURE__ */ new Map();
  Object.keys(modules).forEach((id) => {
    resolvedIds.set(path.resolve(id), modules[id]);
  });
  return {
    name: "virtual",
    resolveId(id, importer) {
      if (id in modules)
        return PREFIX + id;
      if (importer) {
        const importerNoPrefix = importer.startsWith(PREFIX) ? importer.slice(PREFIX.length) : importer;
        const resolved = path.resolve(path.dirname(importerNoPrefix), id);
        if (resolvedIds.has(resolved))
          return PREFIX + resolved;
      }
      return null;
    },
    load(id) {
      if (id.startsWith(PREFIX)) {
        const idNoPrefix = id.slice(PREFIX.length);
        return idNoPrefix in modules ? modules[idNoPrefix] : resolvedIds.get(idNoPrefix);
      }
      return null;
    }
  };
}
class WalkerBase {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node) => this.replacement = node
    };
  }
  replace(parent, prop, index, node) {
    if (parent) {
      if (index !== null) {
        parent[prop][index] = node;
      } else {
        parent[prop] = node;
      }
    }
  }
  remove(parent, prop, index) {
    if (parent) {
      if (index !== null) {
        parent[prop].splice(index, 1);
      } else {
        delete parent[prop];
      }
    }
  }
}
class SyncWalker extends WalkerBase {
  constructor(enter, leave) {
    super();
    this.enter = enter;
    this.leave = leave;
  }
  visit(node, parent, prop, index) {
    if (node) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node;
        if (removed)
          return null;
      }
      for (const key in node) {
        const value = node[key];
        if (typeof value !== "object") {
          continue;
        } else if (Array.isArray(value)) {
          for (let i = 0; i < value.length; i += 1) {
            if (value[i] !== null && typeof value[i].type === "string") {
              if (!this.visit(value[i], node, key, i)) {
                i--;
              }
            }
          }
        } else if (value !== null && typeof value.type === "string") {
          this.visit(value, node, key, null);
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node;
  }
}
function walk(ast, { enter, leave }) {
  const instance = new SyncWalker(enter, leave);
  return instance.visit(ast, null);
}
function parseSharedOptions(options) {
  return parseOptions(
    options.shared || {},
    (value, key) => ({
      import: true,
      shareScope: "default",
      packagePath: key,
      manuallyPackagePathSetting: false,
      generate: true
    }),
    (value, key) => {
      value.import = value.import ?? true;
      value.shareScope = value.shareScope || "default";
      value.packagePath = value.packagePath || key;
      value.manuallyPackagePathSetting = value.packagePath !== key;
      value.generate = value.generate ?? true;
      return value;
    }
  );
}
function parseExposeOptions(options) {
  return parseOptions(
    options.exposes,
    (item) => {
      return {
        import: item,
        name: void 0
      };
    },
    (item) => ({
      import: item.import,
      name: item.name || void 0
    })
  );
}
function parseRemoteOptions(options) {
  return parseOptions(
    options.remotes ? options.remotes : {},
    (item) => ({
      external: Array.isArray(item) ? item : [item],
      shareScope: options.shareScope || "default",
      format: "esm",
      from: "vite",
      externalType: "url"
    }),
    (item) => ({
      external: Array.isArray(item.external) ? item.external : [item.external],
      shareScope: item.shareScope || options.shareScope || "default",
      format: item.format || "esm",
      from: item.from ?? "vite",
      externalType: item.externalType || "url"
    })
  );
}
function parseOptions(options, normalizeSimple, normalizeOptions) {
  if (!options) {
    return [];
  }
  const list = [];
  const array = (items) => {
    for (const item of items) {
      if (typeof item === "string") {
        list.push([item, normalizeSimple(item, item)]);
      } else if (item && typeof item === "object") {
        object(item);
      } else {
        throw new Error("Unexpected options format");
      }
    }
  };
  const object = (obj) => {
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === "string" || Array.isArray(value)) {
        list.push([key, normalizeSimple(value, key)]);
      } else {
        list.push([key, normalizeOptions(value, key)]);
      }
    }
  };
  if (Array.isArray(options)) {
    array(options);
  } else if (typeof options === "object") {
    object(options);
  } else {
    throw new Error("Unexpected options format");
  }
  return list;
}
const letterReg = new RegExp("[0-9a-zA-Z]+");
function removeNonRegLetter(str, reg = letterReg) {
  let needUpperCase = false;
  let ret = "";
  for (const c of str) {
    if (reg.test(c)) {
      ret += needUpperCase ? c.toUpperCase() : c;
      needUpperCase = false;
    } else {
      needUpperCase = true;
    }
  }
  return ret;
}
function getModuleMarker(value, type) {
  return type ? `__rf_${type}__${value}` : `__rf_placeholder__${value}`;
}
function normalizePath(id) {
  return posix.normalize(id.replace(/\\/g, "/"));
}
function createRemotesMap(remotes) {
  const createUrl = (remote) => {
    const external = remote.config.external[0];
    const externalType = remote.config.externalType;
    if (externalType === "promise") {
      return `()=>${external}`;
    } else {
      return `'${external}'`;
    }
  };
  return `const remotesMap = {
${remotes.map(
    (remote) => `'${remote.id}':{url:${createUrl(remote)},format:'${remote.config.format}',from:'${remote.config.from}'}`
  ).join(",\n  ")}
};`;
}
const REMOTE_FROM_PARAMETER = "remoteFrom";
const NAME_CHAR_REG = new RegExp("[0-9a-zA-Z@_-]+");
const EXPOSES_MAP = /* @__PURE__ */ new Map();
const EXPOSES_KEY_MAP = /* @__PURE__ */ new Map();
const SHARED = "shared";
const DYNAMIC_LOADING_CSS = "dynamicLoadingCss";
const DYNAMIC_LOADING_CSS_PREFIX = "__v__css__";
const DEFAULT_ENTRY_FILENAME = "remoteEntry.js";
const builderInfo = {
  builder: "rollup",
  version: "",
  assetsDir: "",
  isHost: false,
  isRemote: false,
  isShared: false
};
const parsedOptions = {
  prodExpose: [],
  prodRemote: [],
  prodShared: [],
  devShared: [],
  devExpose: [],
  devRemote: []
};
const sharedFileName2Prop = /* @__PURE__ */ new Map();
function prodRemotePlugin(options) {
  parsedOptions.prodRemote = parseRemoteOptions(options);
  const remotes = [];
  for (const item of parsedOptions.prodRemote) {
    remotes.push({
      id: item[0],
      regexp: new RegExp(`^${item[0]}/.+?`),
      config: item[1]
    });
  }
  return {
    name: "originjs:remote-production",
    virtualFile: {
      __federation__: `
                ${createRemotesMap(remotes)}
                const loadJS = async (url, fn) => {
                    const resolvedUrl = typeof url === 'function' ? await url() : url;
                    const script = document.createElement('script')
                    script.type = 'text/javascript';
                    script.onload = fn;
                    script.src = resolvedUrl;
                    document.getElementsByTagName('head')[0].appendChild(script);
                }

                function get(name, ${REMOTE_FROM_PARAMETER}) {
                    return __federation_import(name).then(module => () => {
                        if (${REMOTE_FROM_PARAMETER} === 'webpack') {
                            return Object.prototype.toString.call(module).indexOf('Module') > -1 && module.default ? module.default : module
                        }
                        return module
                    })
                }

                const wrapShareModule = ${REMOTE_FROM_PARAMETER} => {
                    return {
                        ${getModuleMarker("shareScope")}
                    }
                }

                async function __federation_import(name) {
                    return import(name);
                }

                const initMap = Object.create(null);

                async function __federation_method_ensure(remoteId) {
                    const remote = remotesMap[remoteId];
                    if (!remote.inited) {
                        if ('var' === remote.format) {
                            // loading js with script tag
                            return new Promise(resolve => {
                                const callback = () => {
                                    if (!remote.inited) {
                                        remote.lib = window[remoteId];
                                        remote.lib.init(wrapShareModule(remote.from))
                                        remote.inited = true;
                                    }
                                    resolve(remote.lib);
                                }
                                return loadJS(remote.url, callback);
                            });
                        } else if (['esm', 'systemjs'].includes(remote.format)) {
                            // loading js with import(...)
                            return new Promise((resolve, reject) => {
                                const getUrl = typeof remote.url === 'function' ? remote.url : () => Promise.resolve(remote.url);
                                getUrl().then(url => {
                                    import(/* @vite-ignore */ url).then(lib => {
                                        if (!remote.inited) {
                                            const shareScope = wrapShareModule(remote.from)
                                            lib.init(shareScope);
                                            remote.lib = lib;
                                            remote.lib.init(shareScope);
                                            remote.inited = true;
                                        }
                                        resolve(remote.lib);
                                    }).catch(reject)
                                })
                            })
                        }
                    } else {
                        return remote.lib;
                    }
                }

                function __federation_method_unwrapDefault(module) {
                    return (module?.__esModule || module?.[Symbol.toStringTag] === 'Module') ? module.default : module
                }

                function __federation_method_wrapDefault(module, need) {
                    if (!module?.default && need) {
                        let obj = Object.create(null);
                        obj.default = module;
                        obj.__esModule = true;
                        return obj;
                    }
                    return module;
                }

                function __federation_method_getRemote(remoteName, componentName) {
                    return __federation_method_ensure(remoteName).then((remote) => remote.get(componentName).then(factory => factory()));
                }

                export {
                    __federation_method_ensure,
                    __federation_method_getRemote,
                    __federation_method_unwrapDefault,
                    __federation_method_wrapDefault
                }
            `
    },
    async transform(code, id) {
      var _a;
      if (builderInfo.isShared) {
        for (const sharedInfo of parsedOptions.prodShared) {
          if (!sharedInfo[1].emitFile) {
            const basename2 = `__federation_shared_${removeNonRegLetter(
              sharedInfo[0],
              NAME_CHAR_REG
            )}.js`;
            sharedInfo[1].emitFile = this.emitFile({
              type: "chunk",
              id: sharedInfo[1].id ?? sharedInfo[1].packagePath,
              fileName: `${builderInfo.assetsDir ? builderInfo.assetsDir + "/" : ""}${sharedInfo[1].root ? sharedInfo[1].root[0] + "/" : ""}${basename2}`,
              preserveSignature: "allow-extension",
              name: sharedInfo[0]
            });
            sharedFileName2Prop.set(basename2, sharedInfo);
          }
        }
        if (id === "\0virtual:__federation_fn_import") {
          const moduleMapCode = parsedOptions.prodShared.filter((shareInfo) => shareInfo[1].generate).map(
            (sharedInfo) => `'${sharedInfo[0]}':{get:()=>()=>__federation_import('./${sharedInfo[1].root ? `${sharedInfo[1].root[0]}/` : ""}${basename(
              this.getFileName(sharedInfo[1].emitFile)
            )}'),import:${sharedInfo[1].import}${sharedInfo[1].requiredVersion ? `,requiredVersion:'${sharedInfo[1].requiredVersion}'` : ""}}`
          ).join(",");
          return code.replace(
            getModuleMarker("moduleMap", "var"),
            `{${moduleMapCode}}`
          );
        }
      }
      if (builderInfo.isRemote) {
        for (const expose of parsedOptions.prodExpose) {
          if (!expose[1].emitFile) {
            if (!expose[1].id) {
              expose[1].id = (_a = await this.resolve(expose[1].import)) == null ? void 0 : _a.id;
              if (!expose[1].id) {
                this.error(
                  `Cannot find file ${expose[1].import}, please check your 'exposes.import' config.`
                );
              }
            }
            expose[1].emitFile = this.emitFile({
              type: "chunk",
              id: expose[1].id,
              name: EXPOSES_KEY_MAP.get(expose[0]),
              preserveSignature: "allow-extension"
            });
          }
        }
      }
      if (builderInfo.isHost) {
        if (id === "\0virtual:__federation__") {
          const res = [];
          parsedOptions.prodShared.forEach((arr) => {
            const obj = arr[1];
            let str = "";
            if (typeof obj === "object") {
              const fileName = `./${basename(this.getFileName(obj.emitFile))}`;
              str += `get:()=>get('${fileName}', ${REMOTE_FROM_PARAMETER}), loaded:1`;
              res.push(`'${arr[0]}':{'${obj.version}':{${str}}}`);
            }
          });
          return code.replace(getModuleMarker("shareScope"), res.join(","));
        }
      }
      if (builderInfo.isHost || builderInfo.isShared) {
        let ast = null;
        try {
          ast = this.parse(code);
        } catch (err) {
          console.error(err);
        }
        if (!ast) {
          return null;
        }
        const magicString = new MagicString(code);
        const hasStaticImported = /* @__PURE__ */ new Map();
        let requiresRuntime = false;
        let hasImportShared = false;
        let modify = false;
        walk(ast, {
          enter(node) {
            var _a2, _b, _c, _d;
            if (node.type === "ImportDeclaration") {
              const moduleName = node.source.value;
              if (parsedOptions.prodShared.some(
                (sharedInfo) => sharedInfo[0] === moduleName
              )) {
                const namedImportDeclaration = [];
                let defaultImportDeclaration = null;
                if (!((_a2 = node.specifiers) == null ? void 0 : _a2.length)) {
                  magicString.remove(node.start, node.end);
                  modify = true;
                } else {
                  node.specifiers.forEach((specify) => {
                    var _a3;
                    if ((_a3 = specify.imported) == null ? void 0 : _a3.name) {
                      namedImportDeclaration.push(
                        `${specify.imported.name === specify.local.name ? specify.imported.name : `${specify.imported.name}:${specify.local.name}`}`
                      );
                    } else {
                      defaultImportDeclaration = specify.local.name;
                    }
                  });
                  hasImportShared = true;
                  if (defaultImportDeclaration && namedImportDeclaration.length) {
                    const imports = namedImportDeclaration.join(",");
                    const line = `const ${defaultImportDeclaration} = await importShared('${moduleName}');
const {${imports}} = ${defaultImportDeclaration};
`;
                    magicString.overwrite(node.start, node.end, line);
                  } else if (defaultImportDeclaration) {
                    magicString.overwrite(
                      node.start,
                      node.end,
                      `const ${defaultImportDeclaration} = await importShared('${moduleName}');
`
                    );
                  } else if (namedImportDeclaration.length) {
                    magicString.overwrite(
                      node.start,
                      node.end,
                      `const {${namedImportDeclaration.join(
                        ","
                      )}} = await importShared('${moduleName}');
`
                    );
                  }
                }
              }
            }
            if ((node.type === "ImportExpression" || node.type === "ImportDeclaration" || node.type === "ExportNamedDeclaration") && ((_c = (_b = node.source) == null ? void 0 : _b.value) == null ? void 0 : _c.indexOf("/")) > -1) {
              const moduleId = node.source.value;
              const remote = remotes.find((r) => r.regexp.test(moduleId));
              const needWrap = (remote == null ? void 0 : remote.config.from) === "vite";
              if (remote) {
                requiresRuntime = true;
                const modName = `.${moduleId.slice(remote.id.length)}`;
                switch (node.type) {
                  case "ImportExpression": {
                    magicString.overwrite(
                      node.start,
                      node.end,
                      `__federation_method_getRemote(${JSON.stringify(
                        remote.id
                      )} , ${JSON.stringify(
                        modName
                      )}).then(module=>__federation_method_wrapDefault(module, ${needWrap}))`
                    );
                    break;
                  }
                  case "ImportDeclaration": {
                    if ((_d = node.specifiers) == null ? void 0 : _d.length) {
                      const afterImportName = `__federation_var_${moduleId.replace(
                        /[@/\\.-]/g,
                        ""
                      )}`;
                      if (!hasStaticImported.has(moduleId)) {
                        hasStaticImported.set(moduleId, afterImportName);
                        magicString.overwrite(
                          node.start,
                          node.end,
                          `const ${afterImportName} = await __federation_method_getRemote(${JSON.stringify(
                            remote.id
                          )} , ${JSON.stringify(modName)});`
                        );
                      }
                      let deconstructStr = "";
                      node.specifiers.forEach((spec) => {
                        if (spec.type === "ImportDefaultSpecifier") {
                          magicString.appendRight(
                            node.end,
                            `
 let ${spec.local.name} = __federation_method_unwrapDefault(${afterImportName}) `
                          );
                        } else if (spec.type === "ImportSpecifier") {
                          const importedName = spec.imported.name;
                          const localName = spec.local.name;
                          deconstructStr += `${importedName === localName ? localName : `${importedName} : ${localName}`},`;
                        } else if (spec.type === "ImportNamespaceSpecifier") {
                          magicString.appendRight(
                            node.end,
                            `let {${spec.local.name}} = ${afterImportName}`
                          );
                        }
                      });
                      if (deconstructStr.length > 0) {
                        magicString.appendRight(
                          node.end,
                          `
 let {${deconstructStr.slice(
                            0,
                            -1
                          )}} = ${afterImportName}`
                        );
                      }
                    }
                    break;
                  }
                  case "ExportNamedDeclaration": {
                    const afterImportName = `__federation_var_${moduleId.replace(
                      /[@/\\.-]/g,
                      ""
                    )}`;
                    if (!hasStaticImported.has(moduleId)) {
                      hasStaticImported.set(moduleId, afterImportName);
                      magicString.overwrite(
                        node.start,
                        node.end,
                        `const ${afterImportName} = await __federation_method_getRemote(${JSON.stringify(
                          remote.id
                        )} , ${JSON.stringify(modName)});`
                      );
                    }
                    if (node.specifiers.length > 0) {
                      const specifiers = node.specifiers;
                      let exportContent = "";
                      let deconstructContent = "";
                      specifiers.forEach((spec) => {
                        const localName = spec.local.name;
                        const exportName = spec.exported.name;
                        const variableName = `${afterImportName}_${localName}`;
                        deconstructContent = deconstructContent.concat(
                          `${localName}:${variableName},`
                        );
                        exportContent = exportContent.concat(
                          `${variableName} as ${exportName},`
                        );
                      });
                      magicString.append(
                        `
 const {${deconstructContent.slice(
                          0,
                          deconstructContent.length - 1
                        )}} = ${afterImportName}; 
`
                      );
                      magicString.append(
                        `
 export {${exportContent.slice(
                          0,
                          exportContent.length - 1
                        )}}; `
                      );
                    }
                    break;
                  }
                }
              }
            }
          }
        });
        if (requiresRuntime) {
          magicString.prepend(
            `import {__federation_method_ensure, __federation_method_getRemote , __federation_method_wrapDefault , __federation_method_unwrapDefault} from '__federation__';

`
          );
        }
        if (hasImportShared) {
          magicString.prepend(
            `import {importShared} from '\0virtual:__federation_fn_import';
`
          );
        }
        if (requiresRuntime || hasImportShared || modify) {
          return magicString.toString();
        }
      }
    }
  };
}
const federation_fn_import = "import { satisfy } from '__federation_fn_satisfy'\n\n// eslint-disable-next-line no-undef\nconst moduleMap = __rf_var__moduleMap\nconst moduleCache = Object.create(null)\nasync function importShared(name, shareScope = 'default') {\n  return moduleCache[name]\n    ? new Promise((r) => r(moduleCache[name]))\n    : (await getSharedFromRuntime(name, shareScope)) || getSharedFromLocal(name)\n}\n// eslint-disable-next-line\nasync function __federation_import(name) {\n  return import(name)\n}\nasync function getSharedFromRuntime(name, shareScope) {\n  let module = null\n  if (globalThis?.__federation_shared__?.[shareScope]?.[name]) {\n    const versionObj = globalThis.__federation_shared__[shareScope][name]\n    const versionKey = Object.keys(versionObj)[0]\n    const versionValue = Object.values(versionObj)[0]\n    if (moduleMap[name]?.requiredVersion) {\n      // judge version satisfy\n      if (satisfy(versionKey, moduleMap[name].requiredVersion)) {\n        module = await (await versionValue.get())()\n      } else {\n        console.log(\n          `provider support ${name}(${versionKey}) is not satisfied requiredVersion(\\${moduleMap[name].requiredVersion})`\n        )\n      }\n    } else {\n      module = await (await versionValue.get())()\n    }\n  }\n  if (module) {\n    if (module.default) module = module.default\n    moduleCache[name] = module\n    return module\n  }\n}\nasync function getSharedFromLocal(name) {\n  if (moduleMap[name]?.import) {\n    let module = await (await moduleMap[name].get())()\n    if (module.default) module = module.default\n    moduleCache[name] = module\n    return module\n  } else {\n    console.error(\n      `consumer config import=false,so cant use callback shared module`\n    )\n  }\n}\nexport {\n  importShared,\n  getSharedFromRuntime as importSharedRuntime,\n  getSharedFromLocal as importSharedLocal\n}\n";
const sharedFilePathReg = /__federation_shared_.+\.js$/;
function prodSharedPlugin(options) {
  parsedOptions.prodShared = parseSharedOptions(options);
  const shareName2Prop = /* @__PURE__ */ new Map();
  parsedOptions.prodShared.forEach(
    (value) => shareName2Prop.set(value[0], value[1])
  );
  const exposesModuleIdSet = /* @__PURE__ */ new Set();
  EXPOSES_MAP.forEach((value) => {
    exposesModuleIdSet.add(`${value}.js`);
  });
  let isHost;
  let isRemote;
  const id2Prop = /* @__PURE__ */ new Map();
  return {
    name: "originjs:shared-production",
    virtualFile: {
      __federation_fn_import: federation_fn_import
    },
    options(inputOptions) {
      var _a;
      isRemote = !!parsedOptions.prodExpose.length;
      isHost = !!parsedOptions.prodRemote.length && !parsedOptions.prodExpose.length;
      if (shareName2Prop.size) {
        inputOptions.external = (_a = inputOptions.external) == null ? void 0 : _a.filter(
          (item) => {
            return !shareName2Prop.has(item);
          }
        );
      }
      return inputOptions;
    },
    async buildStart() {
      var _a;
      if (parsedOptions.prodShared.length && isRemote) {
        this.emitFile({
          fileName: `${builderInfo.assetsDir ? builderInfo.assetsDir + "/" : ""}__federation_fn_import.js`,
          type: "chunk",
          id: "__federation_fn_import",
          preserveSignature: "strict"
        });
      }
      const collectDirFn = (filePath, collect) => {
        const files = readdirSync(filePath);
        files.forEach((name) => {
          const tempPath = join(filePath, name);
          const isDir = statSync(tempPath).isDirectory();
          if (isDir) {
            collect.push(tempPath);
            collectDirFn(tempPath, collect);
          }
        });
      };
      const monoRepos = [];
      const dirPaths = [];
      const currentDir = resolve();
      for (const arr of parsedOptions.prodShared) {
        if (isHost && !arr[1].version && !arr[1].manuallyPackagePathSetting) {
          const packageJsonPath = (_a = await this.resolve(`${arr[1].packagePath}/package.json`)) == null ? void 0 : _a.id;
          if (packageJsonPath) {
            const packageJson = JSON.parse(
              readFileSync(packageJsonPath, { encoding: "utf-8" })
            );
            arr[1].version = packageJson.version;
          } else {
            arr[1].removed = true;
            const dir = join(currentDir, "node_modules", arr[0]);
            const dirStat = statSync(dir);
            if (dirStat.isDirectory()) {
              collectDirFn(dir, dirPaths);
            } else {
              this.error(`cant resolve "${arr[1].packagePath}"`);
            }
            if (dirPaths.length > 0) {
              monoRepos.push({ arr: dirPaths, root: arr });
            }
          }
          if (!arr[1].removed && !arr[1].version) {
            this.error(
              `No description file or no version in description file (usually package.json) of ${arr[0]}. Add version to description file, or manually specify version in shared config.`
            );
          }
        }
      }
      parsedOptions.prodShared = parsedOptions.prodShared.filter(
        (item) => !item[1].removed
      );
      if (monoRepos.length > 0) {
        for (const monoRepo of monoRepos) {
          for (const id of monoRepo.arr) {
            try {
              const idResolve = await this.resolve(id);
              if (idResolve == null ? void 0 : idResolve.id) {
                parsedOptions.prodShared.push([
                  `${monoRepo.root[0]}/${basename(id)}`,
                  {
                    id: idResolve == null ? void 0 : idResolve.id,
                    import: monoRepo.root[1].import,
                    shareScope: monoRepo.root[1].shareScope,
                    root: monoRepo.root
                  }
                ]);
              }
            } catch (e) {
            }
          }
        }
      }
      if (parsedOptions.prodShared.length && isRemote) {
        for (const prod of parsedOptions.prodShared) {
          id2Prop.set(prod[1].id, prod[1]);
        }
      }
    },
    outputOptions: function(outputOption) {
      outputOption.hoistTransitiveImports = false;
      const manualChunkFunc = (id) => {
        const find = parsedOptions.prodShared.find(
          (arr) => {
            var _a;
            return (_a = arr[1].dependencies) == null ? void 0 : _a.has(id);
          }
        );
        return find ? find[0] : void 0;
      };
      if (typeof outputOption.manualChunks === "function") {
        outputOption.manualChunks = new Proxy(outputOption.manualChunks, {
          apply(target, thisArg, argArray) {
            const result = manualChunkFunc(argArray[0]);
            return result ? result : target(argArray[0], argArray[1]);
          }
        });
      }
      if (outputOption.manualChunks === void 0) {
        outputOption.manualChunks = manualChunkFunc;
      }
      return outputOption;
    },
    generateBundle(options2, bundle) {
      if (!isRemote) {
        return;
      }
      const needRemoveShared = /* @__PURE__ */ new Set();
      for (const key in bundle) {
        const chunk = bundle[key];
        if (chunk.type === "chunk") {
          const removeSharedChunk = !isHost && sharedFilePathReg.test(chunk.fileName) && shareName2Prop.has(chunk.name) && !shareName2Prop.get(chunk.name).generate;
          if (removeSharedChunk) {
            needRemoveShared.add(key);
          }
        }
      }
      if (needRemoveShared.size !== 0) {
        for (const key of needRemoveShared) {
          delete bundle[key];
        }
      }
    }
  };
}
function prodExposePlugin(options) {
  let moduleMap = "";
  parsedOptions.prodExpose = parseExposeOptions(options);
  for (const item of parsedOptions.prodExpose) {
    getModuleMarker(`\${${item[0]}}`, SHARED);
    const exposeFilepath = normalizePath(resolve(item[1].import));
    EXPOSES_MAP.set(item[0], exposeFilepath);
    EXPOSES_KEY_MAP.set(
      item[0],
      `__federation_expose_${removeNonRegLetter(item[0], NAME_CHAR_REG)}`
    );
    moduleMap += `
"${item[0]}":()=>{
      ${DYNAMIC_LOADING_CSS}('${DYNAMIC_LOADING_CSS_PREFIX}${exposeFilepath}')
      return __federation_import('\${__federation_expose_${item[0]}}').then(module =>Object.keys(module).every(item => exportSet.has(item)) ? () => module.default : () => module)},`;
  }
  let viteConfigResolved;
  return {
    name: "originjs:expose-production",
    virtualFile: {
      __remoteEntryHelper__: `
      const exportSet = new Set(['Module', '__esModule', 'default', '_export_sfc']);
      let moduleMap = {${moduleMap}}
    const seen = {}
    export const ${DYNAMIC_LOADING_CSS} = (cssFilePaths) => {
      const metaUrl = import.meta.url
      if (typeof metaUrl == 'undefined') {
        console.warn('The remote style takes effect only when the build.target option in the vite.config.ts file is higher than that of "es2020".')
        return
      }
      const curUrl = metaUrl.substring(0, metaUrl.lastIndexOf('${options.filename}'))

      cssFilePaths.forEach(cssFilePath => {
        const href = curUrl + cssFilePath
        if (href in seen) return
        seen[href] = true
        const element = document.head.appendChild(document.createElement('link'))
        element.href = href
        element.rel = 'stylesheet'
      })
    };
    async function __federation_import(name) {
        return import(name);
    };
    export const get =(module) => {
        return moduleMap[module]();
    };
    export const init =(shareScope) => {
      globalThis.__federation_shared__= globalThis.__federation_shared__|| {};
      Object.entries(shareScope).forEach(([key, value]) => {
        const versionKey = Object.keys(value)[0];
        const versionValue = Object.values(value)[0];
        const scope = versionValue.scope || 'default'
        globalThis.__federation_shared__[scope] = globalThis.__federation_shared__[scope] || {};
        const shared= globalThis.__federation_shared__[scope];
        (shared[key] = shared[key]||{})[versionKey] = versionValue;
      });
    }`
    },
    options() {
      return null;
    },
    configResolved(config) {
      viteConfigResolved = config;
    },
    buildStart() {
      if (parsedOptions.prodExpose.length > 0) {
        this.emitFile({
          fileName: `${builderInfo.assetsDir ? builderInfo.assetsDir + "/" : ""}${options.filename}`,
          type: "chunk",
          id: "__remoteEntryHelper__",
          preserveSignature: "strict"
        });
      }
    },
    generateBundle(_options, bundle) {
      let remoteEntryChunk;
      for (const file in bundle) {
        const chunk = bundle[file];
        if ((chunk == null ? void 0 : chunk.facadeModuleId) === "\0virtual:__remoteEntryHelper__") {
          remoteEntryChunk = chunk;
          break;
        }
      }
      if (remoteEntryChunk) {
        const filepathMap = /* @__PURE__ */ new Map();
        const getFilename = (name) => parse(parse(name).name).name;
        const cssBundlesMap = Object.keys(bundle).filter((name) => extname(name) === ".css").reduce((res, name) => {
          const filename = getFilename(name);
          res.set(filename, bundle[name]);
          return res;
        }, /* @__PURE__ */ new Map());
        remoteEntryChunk.code = remoteEntryChunk.code.replace(
          new RegExp(`(["'])${DYNAMIC_LOADING_CSS_PREFIX}.*?\\1`, "g"),
          (str) => {
            if (viteConfigResolved && !viteConfigResolved.build.cssCodeSplit) {
              if (cssBundlesMap.size) {
                return `[${[...cssBundlesMap.values()].map(
                  (cssBundle) => JSON.stringify(basename(cssBundle.fileName))
                ).join(",")}]`;
              } else {
                return "[]";
              }
            }
            const filepath = str.slice(
              (`'` + DYNAMIC_LOADING_CSS_PREFIX).length,
              -1
            );
            if (!filepath || !filepath.length)
              return str;
            let fileBundle = filepathMap.get(filepath);
            if (!fileBundle) {
              fileBundle = Object.values(bundle).find(
                (b) => "facadeModuleId" in b && b.facadeModuleId === filepath
              );
              if (fileBundle)
                filepathMap.set(filepath, fileBundle);
              else
                return str;
            }
            const depCssFiles = /* @__PURE__ */ new Set();
            const addDepCss = (bundleName) => {
              const theBundle = bundle[bundleName];
              if (theBundle && theBundle.viteMetadata) {
                for (const cssFileName of theBundle.viteMetadata.importedCss.values()) {
                  const cssBundle = cssBundlesMap.get(getFilename(cssFileName));
                  if (cssBundle) {
                    depCssFiles.add(cssBundle.fileName);
                  }
                }
              }
              if (theBundle && theBundle.imports && theBundle.imports.length) {
                theBundle.imports.forEach((name) => addDepCss(name));
              }
            };
            [fileBundle.fileName, ...fileBundle.imports].forEach(addDepCss);
            return `[${[...depCssFiles].map((d) => JSON.stringify(basename(d))).join(",")}]`;
          }
        );
        for (const expose of parsedOptions.prodExpose) {
          const module = Object.keys(bundle).find((module2) => {
            const chunk = bundle[module2];
            return chunk.name === EXPOSES_KEY_MAP.get(expose[0]);
          });
          if (module) {
            const chunk = bundle[module];
            const fileRelativePath = relative(
              dirname(remoteEntryChunk.fileName),
              chunk.fileName
            );
            const slashPath = fileRelativePath.replace(/\\/g, "/");
            remoteEntryChunk.code = remoteEntryChunk.code.replace(
              `\${__federation_expose_${expose[0]}}`,
              `./${slashPath}`
            );
          }
        }
        let ast = null;
        try {
          ast = this.parse(remoteEntryChunk.code);
        } catch (err) {
          console.error(err);
        }
        if (!ast) {
          return;
        }
        const magicString = new MagicString(remoteEntryChunk.code);
        walk(ast, {
          enter(node) {
            var _a, _b;
            if (node && node.type === "CallExpression" && typeof ((_a = node.arguments[0]) == null ? void 0 : _a.value) === "string" && ((_b = node.arguments[0]) == null ? void 0 : _b.value.indexOf(
              `${DYNAMIC_LOADING_CSS_PREFIX}`
            )) > -1) {
              magicString.remove(node.start, node.end + 1);
            }
          }
        });
        remoteEntryChunk.code = magicString.toString();
      }
    }
  };
}
function devSharedPlugin(options) {
  parsedOptions.devShared = parseSharedOptions(options);
  return {
    name: "originjs:shared-development"
  };
}
function devRemotePlugin(options) {
  parsedOptions.devRemote = parseRemoteOptions(options);
  const remotes = [];
  for (const item of parsedOptions.devRemote) {
    remotes.push({
      id: item[0],
      regexp: new RegExp(`^${item[0]}/.+?`),
      config: item[1]
    });
  }
  let viteDevServer;
  return {
    name: "originjs:remote-development",
    virtualFile: {
      __federation__: `
${createRemotesMap(remotes)}
const loadJS = async (url, fn) => {
  const resolvedUrl = typeof url === 'function' ? await url() : url;
  const script = document.createElement('script')
  script.type = 'text/javascript';
  script.onload = fn;
  script.src = resolvedUrl;
  document.getElementsByTagName('head')[0].appendChild(script);
}
function get(name, ${REMOTE_FROM_PARAMETER}){
  return import(/* @vite-ignore */ name).then(module => ()=> {
    if (${REMOTE_FROM_PARAMETER} === 'webpack') {
      return Object.prototype.toString.call(module).indexOf('Module') > -1 && module.default ? module.default : module
    }
    return module
  })
}
const wrapShareScope = ${REMOTE_FROM_PARAMETER} => {
  return {
    ${getModuleMarker("shareScope")}
  }
}
const initMap = Object.create(null);
async function __federation_method_ensure(remoteId) {
  const remote = remotesMap[remoteId];
  if (!remote.inited) {
    if ('var' === remote.format) {
      // loading js with script tag
      return new Promise(resolve => {
        const callback = () => {
          if (!remote.inited) {
            remote.lib = window[remoteId];
            remote.lib.init(wrapShareScope(remote.from))
            remote.inited = true;
          }
          resolve(remote.lib);
        }
        return loadJS(remote.url, callback);
      });
    } else if (['esm', 'systemjs'].includes(remote.format)) {
      // loading js with import(...)
      return new Promise((resolve, reject) => {
        const getUrl = typeof remote.url === 'function' ? remote.url : () => Promise.resolve(remote.url);
        getUrl().then(url => {
          import(/* @vite-ignore */ url).then(lib => {
            if (!remote.inited) {
              const shareScope = wrapShareScope(remote.from)
              lib.init(shareScope);
              remote.lib = lib;
              remote.lib.init(shareScope);
              remote.inited = true;
            }
            resolve(remote.lib);
          }).catch(reject)
        })
      })
    }
  } else {
    return remote.lib;
  }
}

function __federation_method_unwrapDefault(module) {
  return (module?.__esModule || module?.[Symbol.toStringTag] === 'Module')?module.default:module
}

function __federation_method_wrapDefault(module ,need){
  if (!module?.default && need) {
    let obj = Object.create(null);
    obj.default = module;
    obj.__esModule = true;
    return obj;
  }
  return module; 
}

function __federation_method_getRemote(remoteName,  componentName){
  return __federation_method_ensure(remoteName).then((remote) => remote.get(componentName).then(factory => factory()));
}
export {__federation_method_ensure, __federation_method_getRemote , __federation_method_unwrapDefault , __federation_method_wrapDefault}
;`
    },
    config(config) {
      if (parsedOptions.devRemote.length) {
        const excludeRemotes = [];
        parsedOptions.devRemote.forEach((item) => excludeRemotes.push(item[0]));
        let optimizeDeps = config.optimizeDeps;
        if (!optimizeDeps) {
          optimizeDeps = config.optimizeDeps = {};
        }
        if (!optimizeDeps.exclude) {
          optimizeDeps.exclude = [];
        }
        optimizeDeps.exclude = optimizeDeps.exclude.concat(excludeRemotes);
      }
    },
    configureServer(server) {
      viteDevServer = server;
    },
    async transform(code, id) {
      var _a;
      if (builderInfo.isHost && !builderInfo.isRemote) {
        for (const arr of parsedOptions.devShared) {
          if (!arr[1].version && !arr[1].manuallyPackagePathSetting) {
            const packageJsonPath = (_a = await this.resolve(`${arr[0]}/package.json`)) == null ? void 0 : _a.id;
            if (!packageJsonPath) {
              this.error(
                `No description file or no version in description file (usually package.json) of ${arr[0]}(${packageJsonPath}). Add version to description file, or manually specify version in shared config.`
              );
            } else {
              const json = JSON.parse(
                readFileSync(packageJsonPath, { encoding: "utf-8" })
              );
              arr[1].version = json.version;
            }
          }
        }
      }
      if (id === "\0virtual:__federation__") {
        const scopeCode = await devSharedScopeCode.call(
          this,
          parsedOptions.devShared
        );
        return code.replace(getModuleMarker("shareScope"), scopeCode.join(","));
      }
      let ast = null;
      try {
        ast = this.parse(code);
      } catch (err) {
        console.error(err);
      }
      if (!ast) {
        return null;
      }
      const magicString = new MagicString(code);
      const hasStaticImported = /* @__PURE__ */ new Map();
      let requiresRuntime = false;
      walk(ast, {
        enter(node) {
          var _a2, _b, _c;
          if ((node.type === "ImportExpression" || node.type === "ImportDeclaration" || node.type === "ExportNamedDeclaration") && ((_b = (_a2 = node.source) == null ? void 0 : _a2.value) == null ? void 0 : _b.indexOf("/")) > -1) {
            const moduleId = node.source.value;
            const remote = remotes.find((r) => r.regexp.test(moduleId));
            const needWrap = (remote == null ? void 0 : remote.config.from) === "vite";
            if (remote) {
              requiresRuntime = true;
              const modName = `.${moduleId.slice(remote.id.length)}`;
              switch (node.type) {
                case "ImportExpression": {
                  magicString.overwrite(
                    node.start,
                    node.end,
                    `__federation_method_getRemote(${JSON.stringify(
                      remote.id
                    )} , ${JSON.stringify(
                      modName
                    )}).then(module=>__federation_method_wrapDefault(module, ${needWrap}))`
                  );
                  break;
                }
                case "ImportDeclaration": {
                  if ((_c = node.specifiers) == null ? void 0 : _c.length) {
                    const afterImportName = `__federation_var_${moduleId.replace(
                      /[@/\\.-]/g,
                      ""
                    )}`;
                    if (!hasStaticImported.has(moduleId)) {
                      magicString.overwrite(
                        node.start,
                        node.end,
                        `const ${afterImportName} = await __federation_method_getRemote(${JSON.stringify(
                          remote.id
                        )} , ${JSON.stringify(modName)});`
                      );
                      hasStaticImported.set(moduleId, afterImportName);
                    }
                    let deconstructStr = "";
                    node.specifiers.forEach((spec) => {
                      if (spec.type === "ImportDefaultSpecifier") {
                        magicString.appendRight(
                          node.end,
                          `
 let ${spec.local.name} = __federation_method_unwrapDefault(${afterImportName}) `
                        );
                      } else if (spec.type === "ImportSpecifier") {
                        const importedName = spec.imported.name;
                        const localName = spec.local.name;
                        deconstructStr += `${importedName === localName ? localName : `${importedName} : ${localName}`},`;
                      } else if (spec.type === "ImportNamespaceSpecifier") {
                        magicString.appendRight(
                          node.end,
                          `let {${spec.local.name}} = ${afterImportName}`
                        );
                      }
                    });
                    if (deconstructStr.length > 0) {
                      magicString.appendRight(
                        node.end,
                        `
 let {${deconstructStr.slice(
                          0,
                          -1
                        )}} = ${afterImportName}`
                      );
                    }
                  }
                  break;
                }
                case "ExportNamedDeclaration": {
                  const afterImportName = `__federation_var_${moduleId.replace(
                    /[@/\\.-]/g,
                    ""
                  )}`;
                  if (!hasStaticImported.has(moduleId)) {
                    hasStaticImported.set(moduleId, afterImportName);
                    magicString.overwrite(
                      node.start,
                      node.end,
                      `const ${afterImportName} = await __federation_method_getRemote(${JSON.stringify(
                        remote.id
                      )} , ${JSON.stringify(modName)});`
                    );
                  }
                  if (node.specifiers.length > 0) {
                    const specifiers = node.specifiers;
                    let exportContent = "";
                    let deconstructContent = "";
                    specifiers.forEach((spec) => {
                      const localName = spec.local.name;
                      const exportName = spec.exported.name;
                      const variableName = `${afterImportName}_${localName}`;
                      deconstructContent = deconstructContent.concat(
                        `${localName}:${variableName},`
                      );
                      exportContent = exportContent.concat(
                        `${variableName} as ${exportName},`
                      );
                    });
                    magicString.append(
                      `
 const {${deconstructContent.slice(
                        0,
                        deconstructContent.length - 1
                      )}} = ${afterImportName}; 
`
                    );
                    magicString.append(
                      `
 export {${exportContent.slice(
                        0,
                        exportContent.length - 1
                      )}}; `
                    );
                  }
                  break;
                }
              }
            }
          }
        }
      });
      if (requiresRuntime) {
        magicString.prepend(
          `import {__federation_method_ensure, __federation_method_getRemote , __federation_method_wrapDefault , __federation_method_unwrapDefault} from '__federation__';

`
        );
      }
      return magicString.toString();
    }
  };
  async function devSharedScopeCode(shared) {
    const hostname = resolveHostname(viteDevServer.config.server);
    const protocol = viteDevServer.config.server.https ? "https" : "http";
    const port = viteDevServer.config.server.port ?? 5e3;
    const regExp = new RegExp(
      `${normalizePath(viteDevServer.config.root)}[/\\\\]`
    );
    let cacheDir = viteDevServer.config.cacheDir;
    cacheDir = `${cacheDir === null || cacheDir === void 0 ? "node_modules/.vite" : normalizePath(cacheDir).split(regExp)[1]}`;
    const res = [];
    if (shared.length) {
      const cwdPath = normalizePath(process.cwd());
      for (const item of shared) {
        const moduleInfo = await this.resolve(item[1].packagePath, void 0, {
          skipSelf: true
        });
        if (!moduleInfo)
          continue;
        const moduleFilePath = normalizePath(moduleInfo.id);
        const idx = moduleFilePath.indexOf(cwdPath);
        const relativePath = idx === 0 ? moduleFilePath.slice(cwdPath.length) : null;
        const sharedName = item[0];
        const obj = item[1];
        let str = "";
        if (typeof obj === "object") {
          const url = relativePath ? `'${protocol}://${hostname.name}:${port}${relativePath}'` : `'${protocol}://${hostname.name}:${port}/${cacheDir}/${sharedName}.js?'`;
          str += `get:()=> get(${url}, ${REMOTE_FROM_PARAMETER})`;
          res.push(`'${sharedName}':{'${obj.version}':{${str}}}`);
        }
      }
    }
    return res;
  }
  function resolveHostname(serverOptions) {
    const optionsHost = serverOptions.host;
    const optionOrigin = serverOptions.origin;
    let host;
    if (optionsHost === void 0 || optionsHost === false || optionsHost === "localhost") {
      host = "127.0.0.1";
    } else if (optionsHost === true) {
      host = void 0;
    } else {
      host = optionsHost;
    }
    let name;
    if (optionOrigin) {
      if (optionOrigin.includes("://")) {
        const [, hostname] = optionOrigin.split("://");
        name = hostname;
      } else {
        name = optionOrigin;
      }
    } else if (optionsHost !== "127.0.0.1" && host === "127.0.0.1" || host === "0.0.0.0" || host === "::" || host === void 0) {
      name = "localhost";
    } else {
      name = host;
    }
    return { host, name };
  }
}
function devExposePlugin(options) {
  parsedOptions.devExpose = parseExposeOptions(options);
  return {
    name: "originjs:expose-development"
  };
}
function federation(options) {
  options.filename = options.filename ? options.filename : DEFAULT_ENTRY_FILENAME;
  let pluginList = [];
  let virtualMod;
  let registerCount = 0;
  function registerPlugins(mode, command) {
    if (mode === "development" || command === "serve") {
      pluginList = [
        devSharedPlugin(options),
        devExposePlugin(options),
        devRemotePlugin(options)
      ];
    } else if (mode === "production" || command === "build") {
      pluginList = [
        prodSharedPlugin(options),
        prodExposePlugin(options),
        prodRemotePlugin(options)
      ];
    } else {
      pluginList = [];
    }
    builderInfo.isHost = !!(parsedOptions.prodRemote.length || parsedOptions.devRemote.length);
    builderInfo.isRemote = !!(parsedOptions.prodExpose.length || parsedOptions.devExpose.length);
    builderInfo.isShared = !!(parsedOptions.prodShared.length || parsedOptions.devShared.length);
    let virtualFiles = {};
    pluginList.forEach((plugin) => {
      if (plugin.virtualFile) {
        virtualFiles = Object.assign(virtualFiles, plugin.virtualFile);
      }
    });
    virtualMod = virtual(virtualFiles);
  }
  return {
    name: "originjs:federation",
    enforce: "post",
    options(_options) {
      var _a;
      if (!registerCount++) {
        registerPlugins(options.mode = options.mode ?? "production", "");
      }
      if (typeof _options.input === "string") {
        _options.input = { index: _options.input };
      }
      _options.external = _options.external || [];
      if (!Array.isArray(_options.external)) {
        _options.external = [_options.external];
      }
      for (const pluginHook of pluginList) {
        (_a = pluginHook.options) == null ? void 0 : _a.call(this, _options);
      }
      return _options;
    },
    config(config, env) {
      var _a, _b;
      options.mode = env.mode;
      registerPlugins(options.mode, env.command);
      registerCount++;
      for (const pluginHook of pluginList) {
        (_a = pluginHook.config) == null ? void 0 : _a.call(this, config, env);
      }
      builderInfo.builder = "vite";
      builderInfo.assetsDir = ((_b = config == null ? void 0 : config.build) == null ? void 0 : _b.assetsDir) ?? "assets";
    },
    configureServer(server) {
      var _a;
      for (const pluginHook of pluginList) {
        (_a = pluginHook.configureServer) == null ? void 0 : _a.call(this, server);
      }
    },
    configResolved(config) {
      var _a;
      for (const pluginHook of pluginList) {
        (_a = pluginHook.configResolved) == null ? void 0 : _a.call(this, config);
      }
    },
    buildStart(inputOptions) {
      var _a;
      for (const pluginHook of pluginList) {
        (_a = pluginHook.buildStart) == null ? void 0 : _a.call(this, inputOptions);
      }
    },
    async resolveId(...args) {
      var _a;
      const v = virtualMod.resolveId.call(this, ...args);
      if (v) {
        return v;
      }
      if (args[0] === "\0virtual:__federation_fn_import") {
        return {
          id: "\0virtual:__federation_fn_import",
          moduleSideEffects: true
        };
      }
      if (args[0] === "__federation_fn_satisfy") {
        const federationId = (_a = await this.resolve("@originjs/vite-plugin-federation")) == null ? void 0 : _a.id;
        return await this.resolve(`${dirname(federationId)}/satisfy.mjs`);
      }
      return null;
    },
    load(...args) {
      const v = virtualMod.load.call(this, ...args);
      if (v) {
        return v;
      }
      return null;
    },
    transform(code, id) {
      var _a;
      for (const pluginHook of pluginList) {
        const result = (_a = pluginHook.transform) == null ? void 0 : _a.call(this, code, id);
        if (result) {
          return result;
        }
      }
      return code;
    },
    moduleParsed(moduleInfo) {
      var _a;
      for (const pluginHook of pluginList) {
        (_a = pluginHook.moduleParsed) == null ? void 0 : _a.call(this, moduleInfo);
      }
    },
    outputOptions(outputOptions) {
      var _a;
      for (const pluginHook of pluginList) {
        (_a = pluginHook.outputOptions) == null ? void 0 : _a.call(this, outputOptions);
      }
      return outputOptions;
    },
    renderChunk(code, chunkInfo, _options) {
      var _a;
      for (const pluginHook of pluginList) {
        const result = (_a = pluginHook.renderChunk) == null ? void 0 : _a.call(
          this,
          code,
          chunkInfo,
          _options
        );
        if (result) {
          return result;
        }
      }
      return null;
    },
    generateBundle: function(_options, bundle, isWrite) {
      var _a;
      for (const pluginHook of pluginList) {
        (_a = pluginHook.generateBundle) == null ? void 0 : _a.call(this, _options, bundle, isWrite);
      }
    }
  };
}
export {
  federation as default
};
